Date: 28th April 2025
Date Modified: 28th April 2025
File Folder: Week 14
#operatingsystems

```ad-abstract
title: Today's Topics
collapse: open

- Topic1
- Topic2
- Topic3

```

# Memory Management

## Requirements for Memory Management Systems

1. Relocation
2. Protection
3. Sharing
4. Logical Organization
5. Physical Organization

### Relocation Requirement

```ad-note
We cannot expect a programmer to know laocation of program in memory
```

Need to swap out blocked processes and swap in ready processes to use memory efficiently
- We cannot expect process to be swapped in at the same memory location

OS and hardware must be able to translate memory references to physical memory addresses

### Protection Requirement

```ad-summary
Any process should not access memory of other processes without permission
```

- Location of process is not known at compile time
- Dynamic allocation and generation of addresses at run time
- Memory references generated by a process must be checked at run time
- OS and processor hardware must check for protection
- Relocation requirement increases difficulty of the protection requirement

### Sharing Requirement

```ad-summary
Memory managment must allow controlled access to shared areas of memory
```

- *Shouldn’t* compromise protection
- Cooperating processes can access shared data structures

### Logically Organization

- Memory is organized **linearly**
- If an operating system can logically organize programs as modules, then programs can:
	- Be written and complied independently
	- Might have different protection
	- Sharing on module level

![[Operating System - Week 14 Day 1 2025-04-28 08.14.07.excalidraw | center]]

### Physical Orgnaization

- Main memory versus secondary memory
- Organizing the flow between memory levels
- Main memory maybe too small  → programmer can employ overlaying
	- But this is too complex for a programmer

# Memory Partitioning

```ad-note
We are going to start at the basics
```

## Introduction

Most modern operating systems use a system called virtual memory:
- Paging
- Segmentation

We are gong to look at an older system to understand core concepts behind virtual memory

## Activity: Painting the Parking Lot

```ad-summary
Imagine having a grid that rperesents the area of an unpainted parking lot. *Paint* the lines that divide the vehicles up in the parking lot
```

### Round 1

```ad-question
**Constraints**:
- Expect trucks, cars, and motorcycles ot park her
- htere must be a least a $1 \times n$ path for vehicles ot navigate
- All parking spaces must be *equally sized*
```

![[Operating System - Week 14 Day 1 2025-04-28 08.20.24.excalidraw | center]]

### Round 2

```ad-question
**Constraints**:
- Expect trucks, cars, and motorcyles to park here
- There must be at least a $1 \times n$ path for the vehicles to navigate
- *Now, youc an paint your parking spots to different sizes*
```

![[Operating System - Week 14 Day 1 2025-04-28 08.28.35.excalidraw | center]]

## How to Partition Memory

Common to have:
1. Region of memory with the operating system
2. The remainder of the memory is broken into partitions with fixed boundaries

*Types of Partitioning*:
- Equal Size
- Unequal Size

![[Pasted image 20250428083615.png | center]]

### Difficulties with Equal-Sized Partitioning

Partition size might be too small:
- If use bigger partition → internal fragmentation
- Fix number of partitions → fixed number of active processes

![[Operating System - Week 14 Day 1 2025-04-28 08.38.33.excalidraw | center]]

```ad-important
Both issues can be lessened by unequal-sized fixed partitions
```

### Placement Algorithms for Unequal-Sized Partitions

 Algorithm $A$:
- Puts the processes in the smallest possible slot it can fit in
- One queue per slot

```ad-warning
title: Issue
What if all processses are under 16M of memory? *You are still wasting space*
```


![[Pasted image 20250428083806.png | center]]

Algorithm $B$:
- One queue for all slots
- Smallest available slot is chosen
- *But* then we need an algorithm to figure out what processes to swap out when more space is needed

![[Pasted image 20250428084148.png | center]]

### Dynamic Partitioning

Partitions are of *variable length* and number
- Allocated exactly as much memory as needed by each processes

```ad-example
1. No processes load
2. Process 1 is loaded
3. Process 2 is loaded
4. Process 3 is loaded
5. Process 2 is swapped out for process 4
6. Process 4 is loaded in
7. All processes are blocked, so process 1 is swapped out to load process 2 back in
8. Process 2 is loaded back in

![[Pasted image 20250428084508.png | center]]
```

```ad-warning
This method can lead to *external fragmentation*
![[Pasted image 20250428084712.png | center]]
```

